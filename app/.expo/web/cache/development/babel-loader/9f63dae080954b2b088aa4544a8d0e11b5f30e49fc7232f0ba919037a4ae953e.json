{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport invariant from 'fbjs/lib/invariant';\nimport canUseDOM from \"../../modules/canUseDom\";\nvar initialURL = canUseDOM ? window.location.href : '';\nvar Linking = function () {\n  function Linking() {\n    _classCallCheck(this, Linking);\n    this._eventCallbacks = {};\n  }\n  _createClass(Linking, [{\n    key: \"_dispatchEvent\",\n    value: function _dispatchEvent(event) {\n      for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        data[_key - 1] = arguments[_key];\n      }\n      var listeners = this._eventCallbacks[event];\n      if (listeners != null && Array.isArray(listeners)) {\n        listeners.map(function (listener) {\n          listener.apply(void 0, data);\n        });\n      }\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(eventType, callback) {\n      var _this = this;\n      if (!_this._eventCallbacks[eventType]) {\n        _this._eventCallbacks[eventType] = [callback];\n      }\n      _this._eventCallbacks[eventType].push(callback);\n      return {\n        remove: function remove() {\n          var callbacks = _this._eventCallbacks[eventType];\n          var filteredCallbacks = callbacks.filter(function (c) {\n            return c.toString() !== callback.toString();\n          });\n          _this._eventCallbacks[eventType] = filteredCallbacks;\n        }\n      };\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(eventType, callback) {\n      console.error(\"Linking.removeEventListener('\" + eventType + \"', ...): Method has been \" + 'deprecated. Please instead use `remove()` on the subscription ' + 'returned by `Linking.addEventListener`.');\n      var callbacks = this._eventCallbacks[eventType];\n      var filteredCallbacks = callbacks.filter(function (c) {\n        return c.toString() !== callback.toString();\n      });\n      this._eventCallbacks[eventType] = filteredCallbacks;\n    }\n  }, {\n    key: \"canOpenURL\",\n    value: function canOpenURL() {\n      return Promise.resolve(true);\n    }\n  }, {\n    key: \"getInitialURL\",\n    value: function getInitialURL() {\n      return Promise.resolve(initialURL);\n    }\n  }, {\n    key: \"openURL\",\n    value: function openURL(url, target) {\n      if (arguments.length === 1) {\n        target = '_blank';\n      }\n      try {\n        open(url, target);\n        this._dispatchEvent('onOpen', url);\n        return Promise.resolve();\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n  }, {\n    key: \"_validateURL\",\n    value: function _validateURL(url) {\n      invariant(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);\n      invariant(url, 'Invalid URL: cannot be empty');\n    }\n  }]);\n  return Linking;\n}();\nvar open = function open(url, target) {\n  if (canUseDOM) {\n    var urlToOpen = new URL(url, window.location).toString();\n    if (urlToOpen.indexOf('tel:') === 0) {\n      window.location = urlToOpen;\n    } else {\n      window.open(urlToOpen, target, 'noopener');\n    }\n  }\n};\nexport default new Linking();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}