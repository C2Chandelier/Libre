{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport AnimatedValue from \"./nodes/AnimatedValue\";\nimport NativeAnimatedHelper from \"./NativeAnimatedHelper\";\nimport invariant from 'fbjs/lib/invariant';\nimport { shouldUseNativeDriver } from \"./NativeAnimatedHelper\";\nvar __DEV__ = process.env.NODE_ENV !== 'production';\nexport function attachNativeEvent(viewRef, eventName, argMapping) {\n  var eventMappings = [];\n  var traverse = function traverse(value, path) {\n    if (value instanceof AnimatedValue) {\n      value.__makeNative();\n      eventMappings.push({\n        nativeEventPath: path,\n        animatedValueTag: value.__getNativeTag()\n      });\n    } else if (typeof value === 'object') {\n      for (var _key in value) {\n        traverse(value[_key], path.concat(_key));\n      }\n    }\n  };\n  invariant(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.');\n  traverse(argMapping[0].nativeEvent, []);\n  if (viewRef != null) {\n    eventMappings.forEach(function (mapping) {\n      NativeAnimatedHelper.API.addAnimatedEventToView(viewRef, eventName, mapping);\n    });\n  }\n  return {\n    detach: function detach() {\n      if (viewRef != null) {\n        eventMappings.forEach(function (mapping) {\n          NativeAnimatedHelper.API.removeAnimatedEventFromView(viewRef, eventName, mapping.animatedValueTag);\n        });\n      }\n    }\n  };\n}\nfunction validateMapping(argMapping, args) {\n  var validate = function validate(recMapping, recEvt, key) {\n    if (recMapping instanceof AnimatedValue) {\n      invariant(typeof recEvt === 'number', 'Bad mapping of event key ' + key + ', should be number but got ' + typeof recEvt);\n      return;\n    }\n    if (typeof recEvt === 'number') {\n      invariant(recMapping instanceof AnimatedValue, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');\n      return;\n    }\n    invariant(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);\n    invariant(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);\n    for (var mappingKey in recMapping) {\n      validate(recMapping[mappingKey], recEvt[mappingKey], mappingKey);\n    }\n  };\n  invariant(args.length >= argMapping.length, 'Event has less arguments than mapping');\n  argMapping.forEach(function (mapping, idx) {\n    validate(mapping, args[idx], 'arg' + idx);\n  });\n}\nexport var AnimatedEvent = function () {\n  function AnimatedEvent(argMapping, config) {\n    _classCallCheck(this, AnimatedEvent);\n    this._listeners = [];\n    this._argMapping = argMapping;\n    if (config == null) {\n      console.warn('Animated.event now requires a second argument for options');\n      config = {\n        useNativeDriver: false\n      };\n    }\n    if (config.listener) {\n      this.__addListener(config.listener);\n    }\n    this._callListeners = this._callListeners.bind(this);\n    this._attachedEvent = null;\n    this.__isNative = shouldUseNativeDriver(config);\n  }\n  _createClass(AnimatedEvent, [{\n    key: \"__addListener\",\n    value: function __addListener(callback) {\n      this._listeners.push(callback);\n    }\n  }, {\n    key: \"__removeListener\",\n    value: function __removeListener(callback) {\n      this._listeners = this._listeners.filter(function (listener) {\n        return listener !== callback;\n      });\n    }\n  }, {\n    key: \"__attach\",\n    value: function __attach(viewRef, eventName) {\n      invariant(this.__isNative, 'Only native driven events need to be attached.');\n      this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);\n    }\n  }, {\n    key: \"__detach\",\n    value: function __detach(viewTag, eventName) {\n      invariant(this.__isNative, 'Only native driven events need to be detached.');\n      this._attachedEvent && this._attachedEvent.detach();\n    }\n  }, {\n    key: \"__getHandler\",\n    value: function __getHandler() {\n      var _this = this;\n      if (this.__isNative) {\n        if (__DEV__) {\n          var _validatedMapping = false;\n          return function () {\n            for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n            if (!_validatedMapping) {\n              validateMapping(_this._argMapping, args);\n              _validatedMapping = true;\n            }\n            _this._callListeners.apply(_this, args);\n          };\n        } else {\n          return this._callListeners;\n        }\n      }\n      var validatedMapping = false;\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        if (__DEV__ && !validatedMapping) {\n          validateMapping(_this._argMapping, args);\n          validatedMapping = true;\n        }\n        var traverse = function traverse(recMapping, recEvt, key) {\n          if (recMapping instanceof AnimatedValue) {\n            if (typeof recEvt === 'number') {\n              recMapping.setValue(recEvt);\n            }\n          } else if (typeof recMapping === 'object') {\n            for (var mappingKey in recMapping) {\n              traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);\n            }\n          }\n        };\n        _this._argMapping.forEach(function (mapping, idx) {\n          traverse(mapping, args[idx], 'arg' + idx);\n        });\n        _this._callListeners.apply(_this, args);\n      };\n    }\n  }, {\n    key: \"_callListeners\",\n    value: function _callListeners() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      this._listeners.forEach(function (listener) {\n        return listener.apply(void 0, args);\n      });\n    }\n  }]);\n  return AnimatedEvent;\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}