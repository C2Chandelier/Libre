{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { useLogger } from \"../contexts\";\nimport { usePanResponder, useSlideAnimation, useViewDimensions } from \"../hooks\";\nimport { noop } from \"../utils/func\";\nimport { bound } from \"../utils/number\";\nimport { getTestId } from \"../utils/test-id\";\nimport { styles } from \"./AnimatedContainer.styles\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function dampingFor(gesture, position) {\n  var moveY = gesture.moveY;\n  switch (position) {\n    case 'bottom':\n      {\n        var _Dimensions$get = Dimensions.get('screen'),\n          screenHeight = _Dimensions$get.height;\n        return Math.abs(screenHeight - moveY);\n      }\n    case 'top':\n      return Math.abs(moveY);\n    default:\n      throw new Error(`Toast position: ${position} not implemented`);\n  }\n}\nexport function animatedValueFor(gesture, position, damping) {\n  var boundValue = function boundValue(val) {\n    return bound(val, 0, 2);\n  };\n  var dy = gesture.dy;\n  switch (position) {\n    case 'bottom':\n      return boundValue(1 - dy / damping);\n    case 'top':\n      return boundValue(1 + dy / damping);\n    default:\n      throw new Error(`Toast position: ${position} not implemented`);\n  }\n}\nexport function AnimatedContainer(_ref) {\n  var children = _ref.children,\n    isVisible = _ref.isVisible,\n    position = _ref.position,\n    topOffset = _ref.topOffset,\n    bottomOffset = _ref.bottomOffset,\n    keyboardOffset = _ref.keyboardOffset,\n    onHide = _ref.onHide,\n    _ref$onRestorePositio = _ref.onRestorePosition,\n    onRestorePosition = _ref$onRestorePositio === void 0 ? noop : _ref$onRestorePositio;\n  var _useLogger = useLogger(),\n    log = _useLogger.log;\n  var _useViewDimensions = useViewDimensions(),\n    computeViewDimensions = _useViewDimensions.computeViewDimensions,\n    height = _useViewDimensions.height;\n  var _useSlideAnimation = useSlideAnimation({\n      position: position,\n      height: height,\n      topOffset: topOffset,\n      bottomOffset: bottomOffset,\n      keyboardOffset: keyboardOffset\n    }),\n    animatedValue = _useSlideAnimation.animatedValue,\n    animate = _useSlideAnimation.animate,\n    animationStyles = _useSlideAnimation.animationStyles;\n  var onDismiss = React.useCallback(function () {\n    log('Swipe, dismissing');\n    animate(0);\n    onHide();\n  }, [animate, log, onHide]);\n  var onRestore = React.useCallback(function () {\n    log('Swipe, restoring to original position');\n    animate(1);\n    onRestorePosition();\n  }, [animate, log, onRestorePosition]);\n  var computeNewAnimatedValueForGesture = React.useCallback(function (gesture) {\n    var damping = dampingFor(gesture, position);\n    var newAnimatedValue = animatedValueFor(gesture, position, damping);\n    return newAnimatedValue;\n  }, [position]);\n  var _usePanResponder = usePanResponder({\n      animatedValue: animatedValue,\n      computeNewAnimatedValueForGesture: computeNewAnimatedValueForGesture,\n      onDismiss: onDismiss,\n      onRestore: onRestore\n    }),\n    panResponder = _usePanResponder.panResponder;\n  React.useLayoutEffect(function () {\n    var newAnimationValue = isVisible ? 1 : 0;\n    animate(newAnimationValue);\n  }, [animate, isVisible]);\n  return _jsx(Animated.View, _objectSpread(_objectSpread({\n    testID: getTestId('AnimatedContainer'),\n    onLayout: computeViewDimensions,\n    style: [styles.base, styles[position], animationStyles],\n    pointerEvents: \"box-none\"\n  }, panResponder.panHandlers), {}, {\n    children: children\n  }));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}