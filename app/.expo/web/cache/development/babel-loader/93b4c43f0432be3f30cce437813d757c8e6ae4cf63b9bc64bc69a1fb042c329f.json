{"ast":null,"code":"'use strict';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport AnimatedProps from \"./nodes/AnimatedProps\";\nimport { AnimatedEvent } from \"./AnimatedEvent\";\nimport useRefEffect from \"../Utilities/useRefEffect\";\nimport NativeAnimatedHelper from \"./NativeAnimatedHelper\";\nimport { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';\nimport useLayoutEffect from \"../../../modules/useLayoutEffect\";\nexport default function useAnimatedProps(props) {\n  var _useReducer = useReducer(function (count) {\n      return count + 1;\n    }, 0),\n    scheduleUpdate = _useReducer[1];\n  var onUpdateRef = useRef(null);\n  var node = useMemo(function () {\n    return new AnimatedProps(props, function () {\n      return onUpdateRef.current == null ? void 0 : onUpdateRef.current();\n    });\n  }, [props]);\n  useAnimatedPropsLifecycle(node);\n  var refEffect = useCallback(function (instance) {\n    node.setNativeView(instance);\n    onUpdateRef.current = function () {\n      scheduleUpdate();\n    };\n    var target = getEventTarget(instance);\n    var events = [];\n    for (var propName in props) {\n      var propValue = props[propName];\n      if (propValue instanceof AnimatedEvent && propValue.__isNative) {\n        propValue.__attach(target, propName);\n        events.push([propName, propValue]);\n      }\n    }\n    return function () {\n      onUpdateRef.current = null;\n      for (var _i = 0, _events = events; _i < _events.length; _i++) {\n        var _events$_i = _events[_i],\n          _propName = _events$_i[0],\n          _propValue = _events$_i[1];\n        _propValue.__detach(target, _propName);\n      }\n    };\n  }, [props, node]);\n  var callbackRef = useRefEffect(refEffect);\n  return [reduceAnimatedProps(node), callbackRef];\n}\nfunction reduceAnimatedProps(node) {\n  return _objectSpread(_objectSpread({}, node.__getValue()), {}, {\n    collapsable: false\n  });\n}\nfunction useAnimatedPropsLifecycle(node) {\n  var prevNodeRef = useRef(null);\n  var isUnmountingRef = useRef(false);\n  useEffect(function () {\n    NativeAnimatedHelper.API.flushQueue();\n  });\n  useLayoutEffect(function () {\n    isUnmountingRef.current = false;\n    return function () {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n  useLayoutEffect(function () {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      var prevNode = prevNodeRef.current;\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return function () {\n      if (isUnmountingRef.current) {\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\nfunction getEventTarget(instance) {\n  return typeof instance === 'object' && typeof (instance == null ? void 0 : instance.getScrollableNode) === 'function' ? instance.getScrollableNode() : instance;\n}\nfunction isFabricInstance(instance) {\n  var _instance$getScrollRe;\n  return hasFabricHandle(instance) || hasFabricHandle(instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()) || hasFabricHandle(instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef());\n}\nfunction hasFabricHandle(instance) {\n  var _instance$_internalIn, _instance$_internalIn2;\n  return (instance == null ? void 0 : (_instance$_internalIn = instance['_internalInstanceHandle']) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}