{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport invariant from 'fbjs/lib/invariant';\nexport var CellRenderMask = function () {\n  function CellRenderMask(numCells) {\n    _classCallCheck(this, CellRenderMask);\n    invariant(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');\n    this._numCells = numCells;\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [{\n        first: 0,\n        last: numCells - 1,\n        isSpacer: true\n      }];\n    }\n  }\n  _createClass(CellRenderMask, [{\n    key: \"enumerateRegions\",\n    value: function enumerateRegions() {\n      return this._regions;\n    }\n  }, {\n    key: \"addCells\",\n    value: function addCells(cells) {\n      var _this$_regions;\n      invariant(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');\n      if (cells.last < cells.first) {\n        return;\n      }\n      var _this$_findRegion = this._findRegion(cells.first),\n        firstIntersect = _this$_findRegion[0],\n        firstIntersectIdx = _this$_findRegion[1];\n      var _this$_findRegion2 = this._findRegion(cells.last),\n        lastIntersect = _this$_findRegion2[0],\n        lastIntersectIdx = _this$_findRegion2[1];\n      if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n        return;\n      }\n      var newLeadRegion = [];\n      var newTailRegion = [];\n      var newMainRegion = _objectSpread(_objectSpread({}, cells), {}, {\n        isSpacer: false\n      });\n      if (firstIntersect.first < newMainRegion.first) {\n        if (firstIntersect.isSpacer) {\n          newLeadRegion.push({\n            first: firstIntersect.first,\n            last: newMainRegion.first - 1,\n            isSpacer: true\n          });\n        } else {\n          newMainRegion.first = firstIntersect.first;\n        }\n      }\n      if (lastIntersect.last > newMainRegion.last) {\n        if (lastIntersect.isSpacer) {\n          newTailRegion.push({\n            first: newMainRegion.last + 1,\n            last: lastIntersect.last,\n            isSpacer: true\n          });\n        } else {\n          newMainRegion.last = lastIntersect.last;\n        }\n      }\n      var replacementRegions = [].concat(newLeadRegion, [newMainRegion], newTailRegion);\n      var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n      (_this$_regions = this._regions).splice.apply(_this$_regions, [firstIntersectIdx, numRegionsToDelete].concat(_toConsumableArray(replacementRegions)));\n    }\n  }, {\n    key: \"numCells\",\n    value: function numCells() {\n      return this._numCells;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every(function (region, i) {\n        return region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer;\n      });\n    }\n  }, {\n    key: \"_findRegion\",\n    value: function _findRegion(cellIdx) {\n      var firstIdx = 0;\n      var lastIdx = this._regions.length - 1;\n      while (firstIdx <= lastIdx) {\n        var middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        var middleRegion = this._regions[middleIdx];\n        if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n          return [middleRegion, middleIdx];\n        } else if (cellIdx < middleRegion.first) {\n          lastIdx = middleIdx - 1;\n        } else if (cellIdx > middleRegion.last) {\n          firstIdx = middleIdx + 1;\n        }\n      }\n      invariant(false, \"A region was not found containing cellIdx \" + cellIdx);\n    }\n  }]);\n  return CellRenderMask;\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}